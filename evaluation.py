import torch
import torch.nn.functional as F

import math

import mil
import visualization

def Grad_CAM_Eval(model: torch.nn.Module,
                  input: torch.Tensor,
                  prediction: torch.Tensor, 
                  label:int=0) -> torch.Tensor:
    """This function computes the GradCam heatmap for the given input image.
    Note thar computing the loss using a Sum or a Mean operation may produce different gradients.
    Since the gradients are computed taking into account the value of the loss, I think that using the 
    Sum operation or the Mean operation may produce different gradients... Investigate this!

    Args:
        model (torch.nn.Module): Weights of the model to be evaluated
        input (torch.Tensor): Batch of input image. Shape: (batch_size, channels, height, width)
        prediction (torch.Tensor): Prediction of the model. Shape: (batch_size, num_classes)
        label (int, optional): Class to produce the GradCam heatmap. Defaults to 0.

    Returns:
        torch.Tensor: GradCam heatmap normalized (min-max normalization)
    """

    model.zero_grad() 
    
    #torch.sum(prediction[:,label]).backward(retain_graph=True)
    torch.mean(prediction[:,label]).backward(retain_graph=True)

    gradients = model.get_activations_gradient()
    activations = model.get_activations(input).detach()
    
    grad_activations = activations * gradients
    
    heatmap = torch.sum(grad_activations, dim=1).squeeze()
    heatmap = F.relu(heatmap)
    heatmap = heatmap.reshape(heatmap.size()[0], int((heatmap.size()[-1])**2)) # Output shape: (batch_size, N)
    heatmap_max,_ = torch.max(heatmap, dim=1)
    heatmap_norm = heatmap / heatmap_max.view(-1,1)
    heatmap_norm = heatmap_norm.reshape(heatmap.size()[0], int(math.sqrt(heatmap.size()[-1])), int(math.sqrt(heatmap.size()[-1])))       
            
    return heatmap_norm

def Compute_ROIs(model: torch.nn.Module,
                 input: torch.Tensor,
                 mask: torch.Tensor,
                 args=None) -> torch.Tensor:
    """This function computes the ROIs for the different MIL pooling operators.
    This function is analogous to the functions used for visualization of the ROIs.
    
    In this function we will compute the ROIs for the Instance and Embedding-level approaches
    We will use the ROIs identified in the Probability heatmap and by the Grad-CAM method.
    
    Args:
        model (torch.nn.Module): Weights of the model to be evaluated
        input (torch.Tensor): Batch of input image. Shape: (batch_size, channels, height, width)
        mask (torch.Tensor): Binary mask of the lesion. Shape: (batch_size, 1, height, width)
        args (_type_, optional): Arguments. Defaults to None.
        
    Returns:
        patch_prob (torch.Tensor): Probability heatmap for the patches in the image
        grad_cam_mel (torch.Tensor): GradCam visualization of the ROIs
    """

    # (1) Compute the output of the model
    bag_prob = model(input, None) if not args.mask_val else model(input, mask)
            
    # (2) Compute the ROIs for the different MIL pooling approaches
    patch_prob = None; grad_cam = None

    if args.mil_type == 'instance':
        patch_prob = model.get_patch_probs() # Obtain patch probabilities
        patch_prob = patch_prob.permute(0, 2, 1)
        patch_prob = patch_prob.reshape(patch_prob.size()[0], args.nb_classes, int(math.sqrt(patch_prob.size()[-1])), int(math.sqrt(patch_prob.size()[-1]))) # Output shape: (batch_size, nb_classes, 14, 14)
        grad_cam = Grad_CAM_Eval(model, input, bag_prob, 0)
    elif args.mil_type == 'embedding':
        grad_cam = Grad_CAM_Eval(input, model, bag_prob, 0)
    else:
        raise ValueError('MIL type not supported... Yet!')
        
    return patch_prob, grad_cam



def Basic_Evaluation_ROIs(model: torch.nn.Module, 
                          dataloader: torch.utils.data.DataLoader, 
                          device: torch.device,
                          args=None):
    """Evaluate the quality of the ROIs generated by the model.
    This function measures the number of patches of the ROI that 
    are inside the ground truth segmentation mask of the lesion.
    
    This function performs the following operations:
    
        1. Generates the ROIs for the different MIL pooling operators
        2. Generates a ROI binary mask
        3. Computes the intersection between the ROI mask and the ground truth
        4. Compute Basic metrics:
            4.1. Acc: Divides the intersection by the number of patches of the ROI
            4.2. Loss: Subtracts the intersection to the number of patches of the ROI. 
                 Then divides by the number of patches of the ROI (Loss = 1 - Acc)

    Args:
        model (torch.nn.Module): Model to be evaluated
        dataloader (torch.utils.data.DataLoader): Dataloader for the evaluation
        device (torch.device): Device to run the evaluation on
        args (_type_, optional): Arguments. Defaults to None.
    """
    
    # (1) Set the model to evaluation mode
    model.eval()
    
    # (2) Iterate over the dataloader
    for input, target, input_idx, mask in dataloader:
            
        # (3) Set input, target and mask to the device
        input, target, mask = input.to(device, non_blocking=True), target.to(device, non_blocking=True), mask.to(device, non_blocking=True)
        
        # (4) Compute the ROIs
        patch_prob, grad_cam = Compute_ROIs(model, input, mask, args)
        
        # (5) Generate the ROI binary mask
        print(patch_prob.shape)
        mel_patch_prob = patch_prob[:,0,:,:]
        segment_patch_prob = (mel_patch_prob > 0.5).float(); segment_grad_cam = (grad_cam > 0.0).float()
        
        # (6) Process segmentation mask
        mask = mil.Mask_Setup(mask)
        mask = mask.reshape(mask.size()[0], int(math.sqrt(mask.size()[1])), int(math.sqrt(mask.size()[1]))) # Output shape: (batch_size, 14, 14)
        
        # (7) Compute the intersection between the ROI mask and the ground truth
        if args.mil_type == 'instance':
            roi_in_mask = segment_patch_prob * mask 
        grad_in_mask = segment_grad_cam * mask
        
        # (8) Compute the basic metrics
        if args.mil_type == 'instance':
            acc_roi = torch.sum(roi_in_mask).item() / torch.sum(segment_patch_prob).item()
        acc_grad = torch.sum(grad_in_mask).item() / torch.sum(segment_grad_cam).item()     